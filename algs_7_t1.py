"""1). Отсортируйте по убыванию методом пузырька одномерный целочисленный массив, заданный случайными числами
на промежутке [-100; 100). Выведите на экран исходный и отсортированный массивы.
Примечания:
● алгоритм сортировки должен быть в виде функции, которая принимает на вход массив данных,
● постарайтесь сделать алгоритм умнее, но помните, что у вас должна остаться сортировка пузырьком.
Улучшенные версии сортировки, например, расчёской, шейкерная и другие в зачёт не идут."""

import random

MIN_ITEM = -100
MAX_ITEM = 100 - 1
SIZE = 10

array = [random.randint(MIN_ITEM, MAX_ITEM) for i in range(SIZE)]

len_sep = len(str(array))
sep_1 = "*" * len_sep
sep_2 = "_" * len_sep

def bubble_sort(arr):
    """
    Для наглядности работы функции нужно разкоментировать строки 43 и 46
    """
    print(f'Исходный массив:\n{arr}\n{sep_1}')  # вывожу исходный массив
    n = 1  # переменая, необходимая для ограничивания самого правого элемента для сортировки
    sort = 0  # счетчик сортировок во внутреннем цикле
    count_sort = 0  # общий счетчик сортировок
    j = len(arr)  # в дальнейшем будет индексом последнего отсортированного элемента за цикл
    while n < len(arr):
        if n > 1:  # для всех кроме первого прохода алгоритма проверяю условие
            if sort > 0:  # если сортировки в прошлом цикле были
                sort = 0  # обнуляю счетчик сортировок
            else:  # если сортировок не было - досрочно выхожу из программы и вывожу результат
                return f'Досрочное заверешение функции!\nОтсортированный массив:\n{arr}\nБыло проведено {count_sort}' \
                       f' перестановок в {n - 1} циклах'

        for i in range(len(arr) - n):  # прохожу по всему массиву до самого крайнего значения - n, которое увеличивается
            if i < j:  # если текущий элемент левее последнего отсортированного в прошло цикле
                if arr[i] < arr[i + 1]:  # провожу его сравнение с правым элементом
                    arr[i], arr[i + 1] = arr[i + 1], arr[i]  # если условие соблюдается - меняю их местами
                    sort += 1  # увеличиваю счетчик сортировок во внутреннем цикле
                    count_sort += 1  # увеличиваю общий счетчик сортировок
#                    print(f'{sep_2}\n{n}.{arr} - {count_sort} перестановка. ')
        j = i  # присваиваю j индекс последнего сортированного элемента
        n += 1  # увеличиваю отступ справа для
#        print(sep_1)
    return f'{sep_1}\nФункции прошла полный цикл:\nОтсортированный массив:\n{arr}\nБыло проведено {count_sort}' \
           f' перестановок в {n - 1} циклах'


print(bubble_sort(array))
